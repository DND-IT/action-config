name: 'action-config'
description: 'Github Action for reading configuration files and generating workflow matrices'
author: 'group:default/dai'

inputs:
  config-path:
    description: 'Path to the configuration file (JSON or YAML)'
    required: true
    default: '.github/matrix-config.json'

outputs:
  matrix:
    description: 'JSON string containing the matrix configuration'
    value: ${{ steps.read-config.outputs.matrix }}

runs:
  using: 'composite'
  steps:
    - name: Read configuration file
      id: read-config
      shell: bash
      run: |
        CONFIG_FILE="${{ inputs.config-path }}"

        if [ ! -f "$CONFIG_FILE" ]; then
          echo "::error::Configuration file not found: $CONFIG_FILE"
          exit 1
        fi

        # Detect file type and read accordingly
        if [[ "$CONFIG_FILE" == *.json ]]; then
          # Validate and minify JSON
          if ! CONFIG=$(jq -c '.' "$CONFIG_FILE" 2>&1); then
            echo "::error::Invalid JSON in $CONFIG_FILE: $CONFIG"
            exit 1
          fi
        elif [[ "$CONFIG_FILE" == *.yaml ]] || [[ "$CONFIG_FILE" == *.yml ]]; then
          # Convert YAML to JSON
          if ! command -v yq &> /dev/null; then
            echo "::error::yq is required to parse YAML files. Please install it first."
            exit 1
          fi
          if ! CONFIG=$(yq -o=json -I=0 '.' "$CONFIG_FILE" 2>&1); then
            echo "::error::Invalid YAML in $CONFIG_FILE: $CONFIG"
            exit 1
          fi
        else
          echo "::error::Unsupported file type. Use .json, .yaml, or .yml"
          exit 1
        fi

        # Config must be an object
        if ! echo "$CONFIG" | jq -e 'type == "object"' > /dev/null 2>&1; then
          echo "::error::Configuration must be an object"
          exit 1
        fi

        # Expand lists into Cartesian product matrix
        MATRIX=$(echo "$CONFIG" | jq -c '
          # Helper function to singularize common plural keys
          def singularize:
            if endswith("ies") then
              .[:-3] + "y"
            elif endswith("es") then
              .[:-2]
            elif endswith("s") then
              .[:-1]
            else
              .
            end;

          . as $root |

          # Helper: check if an item matches all key/value pairs in a pattern
          def matches(pattern):
            . as $item |
            all(pattern | to_entries[]; .key as $k | .value as $v | $item[$k] == $v);

          # Derive environment dimension from config keys if "config" exists
          (if $root.config then
            [{key: "environments", value: ($root.config | keys)}]
          else
            []
          end) as $config_dimensions |

          # Extract explicit dimension arrays (exclude reserved keys)
          (to_entries | map(select(
            (.value | type == "array") and
            (.key != "exclude") and
            (.key != "include")
          ))) as $explicit_dimensions |

          # Merge: explicit dimensions + config-derived (config-derived only adds if not already present)
          ($explicit_dimensions | map(.key)) as $explicit_keys |
          ($explicit_dimensions + ($config_dimensions | map(select(.key as $k | $explicit_keys | index($k) | not)))) as $dimensions |

          # Get base config (non-array values, excluding reserved keys)
          ($root | to_entries | map(select(
            (.value | type != "array") and
            (.key != "config") and
            (.key != "exclude") and
            (.key != "include")
          )) | from_entries) as $base_config |

          # Build cartesian product
          (if ($dimensions | length) == 0 then
            [$root | del(.config) | del(.exclude) | del(.include)]
          else
            $dimensions |
            reduce .[] as $dim (
              [{}];
              [.[] as $item |
               $dim.value[] as $val |
               $item + {($dim.key | singularize): $val}]
            ) |

            # For each combination, merge with corresponding config
            map(. as $combo |
              $base_config |
              . + $combo |
              if $root.config then
                . + (
                  $combo | to_entries |
                  map($root.config[.value] // {}) |
                  add // {}
                )
              else . end
            )
          end) |

          # Apply excludes
          if $root.exclude then
            map(select(. as $item |
              all($root.exclude[]; . as $pattern | ($item | matches($pattern)) | not)
            ))
          else . end |

          # Append includes
          if $root.include then . + $root.include else . end
        ')

        if [ $? -ne 0 ]; then
          echo "::error::Failed to expand configuration"
          exit 1
        fi

        # Output the matrix
        echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

        # Pretty print for logs
        echo "::notice::Matrix configuration loaded successfully:"
        echo "$MATRIX" | jq '.'

branding:
  icon: 'zap'
  color: 'blue'
